module Morphir.TypeScript.PrettyPrinter exposing (mapCompilationUnit, mapTypeDef)

{-| This module contains a pretty-printer that takes a TypeScript AST as an input and returns a formatted text
representation.

@docs mapCompilationUnit, mapTypeDef, mapTypeExp

-}

import Morphir.File.SourceCode exposing (Doc, concat, indentLines, newLine)
import Morphir.TypeScript.AST as TS exposing (FunctionScope(..), ImportDeclaration, Module, NamespacePath, Parameter, Privacy(..), Statement(..), TSExpression(..), TypeDef(..), TypeExp(..))
import Morphir.TypeScript.PrettyPrinter.Expressions exposing (..)


{-| Indent used in pretty printer. Note that we post-process the output with
Prettier (<https://prettier.io/>) so changing this value won't affect the
generated output.
-}
defaultIndent =
    2


{-| -}
mapCompilationUnit : Module -> Doc
mapCompilationUnit cu =
    case cu of
        { imports, exports, typeDefs, statements } ->
            concat
                [ "// Generated by Morphir"
                , newLine ++ newLine
                , imports
                    |> List.map mapImportDeclaration
                    |> String.join newLine
                , newLine ++ newLine
                , typeDefs
                    |> List.map mapTypeDef
                    |> List.map (\mappedTypeDef -> mappedTypeDef ++ newLine ++ newLine)
                    |> String.join newLine
                , statements
                    |> List.map mapStatement
                    |> List.map (\mappedStatement -> mappedStatement ++ newLine ++ newLine)
                    |> String.join newLine
                , newLine ++ newLine
                , "export default { " ++ String.join ", " exports ++ " }"
                , newLine
                ]


mapImportDeclaration : ImportDeclaration -> String
mapImportDeclaration { importClause, moduleSpecifier } =
    concat
        [ "import "
        , importClause
        , " from "
        , "\"" ++ moduleSpecifier ++ "\""
        ]


exportIfPublic : Privacy -> String
exportIfPublic privacy =
    case privacy of
        Public ->
            "export "

        Private ->
            ""


{-| Map a type definition to text.
-}
mapTypeDef : TypeDef -> Doc
mapTypeDef typeDef =
    case typeDef of
        Namespace { name, privacy, content } ->
            concat
                [ privacy |> exportIfPublic
                , "namespace "
                , name
                , " {" ++ newLine
                , content
                    |> List.map mapTypeDef
                    |> List.map (\mappedTypeDef -> mappedTypeDef ++ newLine)
                    |> indentLines defaultIndent
                , newLine ++ "}"
                ]

        TypeAlias { name, privacy, doc, variables, typeExpression, decoder, encoder } ->
            let
                docstring =
                    if String.length doc > 0 then
                        String.concat [ "/*", doc, "*/" ]

                    else
                        ""
            in
            concat
                [ docstring
                , newLine
                , privacy |> exportIfPublic
                , "type "
                , name
                , mapGenericVariables variables
                , " = "
                , mapTypeExp typeExpression
                , newLine
                , newLine
                , mapMaybeStatement decoder
                , newLine
                , newLine
                , mapMaybeStatement encoder
                ]

        VariantClass { name, privacy, variables, body, constructor, decoder, encoder } ->
            let
                preface : String
                preface =
                    concat
                        [ privacy |> exportIfPublic
                        , "class "
                        , name
                        , mapGenericVariables variables
                        , " {"
                        ]

                mainbody : List String
                mainbody =
                    [ body |> List.map mapStatement >> String.join newLine
                    , newLine
                    , mapMaybeStatement constructor
                    ]
            in
            concat
                [ preface
                , newLine
                , mainbody |> indentLines defaultIndent
                , "}"
                , newLine
                , newLine
                , mapMaybeStatement decoder
                , newLine
                , newLine
                , mapMaybeStatement encoder
                , newLine
                ]

        ImportAlias { name, privacy, namespacePath } ->
            concat
                [ privacy |> exportIfPublic
                , "import "
                , name
                , " = "
                , namespaceNameFromPackageAndModule (Tuple.first namespacePath) (Tuple.second namespacePath)
                ]


mapExpression : TSExpression -> String
mapExpression expression =
    case expression of
        ArrayLiteralExpression values ->
            concat
                [ "["
                , String.join ", " (values |> List.map mapExpression)
                , "]"
                ]

        Call { function, arguments } ->
            concat
                [ mapExpression function
                , "("
                , String.join ", " (arguments |> List.map mapExpression)
                , ")"
                ]

        Identifier name ->
            name

        LiteralExpression exp ->
            mapLiteralExpression exp

        IndexedExpression { object, index } ->
            concat
                [ mapExpression object
                , "["
                , mapExpression index
                , "]"
                ]

        MemberExpression { object, member } ->
            case object of
                Identifier "" ->
                    mapExpression member

                _ ->
                    concat
                        [ mapExpression object
                        , "."
                        , mapExpression member
                        ]

        NewExpression { constructor, arguments } ->
            concat
                [ "new "
                , constructor
                , "("
                , arguments |> List.map mapExpression |> String.join ", "
                , ")"
                ]

        NullLiteral ->
            "null"

        ObjectLiteralExpression { properties } ->
            let
                mapObjectField : ( String, TSExpression ) -> String
                mapObjectField ( fieldName, fieldValue ) =
                    concat
                        [ fieldName
                        , ": "
                        , fieldValue |> mapExpression
                        ]
            in
            concat
                [ "{"
                , String.join ", " (properties |> List.map mapObjectField)
                , "}"
                ]

        IfElse cond thenBranch elseBranch ->
            concat
                [ "if (" ++ mapExpression cond ++ ") {"
                , mapExpression thenBranch
                , "} else {"
                , mapExpression elseBranch
                , "}"
                ]

        ArrowFunction { params, body } ->
            concat
                [ "((" ++ String.join ", " params ++ ") => {"
                , mapExpression body
                , "})"
                ]


mapLiteralExpression : TS.Literal -> String
mapLiteralExpression literal =
    case literal of
        TS.FloatNumberLiteral float ->
            String.fromFloat float

        TS.IntNumberLiteral int ->
            String.fromInt int

        TS.BooleanLiteral bool ->
            if bool then
                "true"

            else
                "false"

        TS.StringLiteral string ->
            concat
                [ "\""
                , string
                , "\""
                ]


mapMaybeStatement : Maybe Statement -> String
mapMaybeStatement maybeStatement =
    case maybeStatement of
        Just statement ->
            mapStatement statement

        Nothing ->
            ""


mapStatement : Statement -> String
mapStatement statement =
    case statement of
        FunctionDeclaration { name, typeVariables, returnType, parameters, body } scope privacy ->
            let
                prefaceKeywords : String
                prefaceKeywords =
                    case scope of
                        ModuleFunction ->
                            concat
                                [ privacy |> exportIfPublic
                                , "function "
                                ]

                        ClassStaticFunction ->
                            concat
                                [ "static "
                                ]

                        _ ->
                            ""

                typeVariablesString : String
                typeVariablesString =
                    case typeVariables of
                        [] ->
                            ""

                        _ ->
                            concat
                                [ "<"
                                , String.join ", " (typeVariables |> List.map mapTypeExp)
                                , ">"
                                ]

                returnTypeExpression : String
                returnTypeExpression =
                    case returnType of
                        Nothing ->
                            ""

                        Just typeExp ->
                            concat [ ": ", mapTypeExp typeExp ]
            in
            concat
                [ prefaceKeywords
                , name
                , typeVariablesString
                , "("
                , String.join ", " (parameters |> List.map mapParameter)
                , ")"
                , returnTypeExpression
                , " {"
                , newLine
                , body |> List.map mapStatement |> indentLines defaultIndent
                , newLine
                , "}"
                ]

        ReturnStatement expression ->
            concat [ "return ", mapExpression expression, ";" ]

        ConstStatement lhsExpression maybeAnnotation rhsExpression ->
            concat
                [ "const "
                , mapExpression lhsExpression
                , mapMaybeAnnotation maybeAnnotation
                , " = "
                , mapExpression rhsExpression
                , ";"
                ]

        AssignmentStatement lhsExpression maybeAnnotation rhsExpression ->
            concat
                [ mapExpression lhsExpression
                , mapMaybeAnnotation maybeAnnotation
                , " = "
                , mapExpression rhsExpression
                , ";"
                ]

        ExpressionStatement expression ->
            concat [ mapExpression expression, ";" ]

        SwitchStatement condition cases ->
            let
                mapCase : ( TSExpression, List Statement ) -> String
                mapCase ( caseExpr, statementList ) =
                    concat
                        [ "case "
                        , mapExpression caseExpr
                        , ":"
                        , statementList |> List.map mapStatement |> indentLines defaultIndent
                        ]
            in
            concat
                [ "switch ("
                , mapExpression condition
                , ") {"
                , newLine
                , cases |> List.map mapCase |> indentLines defaultIndent
                , newLine
                , "}"
                ]
